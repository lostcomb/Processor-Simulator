{-
This file is part of aca-processor-simulator.

aca-processor-simulator is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

aca-processor-simulator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with aca-processor-simulator.  If not, see <http://www.gnu.org/licenses/>.
-}
module Assembler
  ( assembler_main
  , assembler_msg
  ) where

import Assembler.Parser
import Assembler.Assembler

import System.Exit
import System.FilePath
import System.Console.GetOpt
import Control.Monad
import qualified Data.ByteString.Lazy as BS

data Flag = Parse
          | Assemble
          | Help
          deriving (Show, Eq, Read)

options :: [ OptDescr Flag ]
options
  = [ Option ['p'] ["parse"]    (NoArg Parse)
      "Outputs the abstract syntax tree generated by the parser."
    , Option ['a'] ["assemble"] (NoArg Assemble)
      "Outputs the assembled assembly in plain text."
    , Option []    ["help"]     (NoArg Help)
      "Prints this help message."
    ]

assembler_main :: [ String ] -> IO ()
assembler_main args = case getOpt Permute options args of
  (args, rp:fs,   []) -> if Help `elem` args
                           then putStrLn $ usageInfo header options
                           else do input <- readFile rp
                                   let parsed    = parse input
                                       assembled = assemble parsed
                                       binary    = assembleBinary parsed
                                   when (Parse `elem` args) $
                                     writeFile (replaceExtension rp ".ass_syn")
                                               (show parsed)
                                   when (Assemble `elem` args) $
                                     writeFile (replaceExtension rp ".assembled")
                                               (unlines . map show $ assembled)
                                   BS.writeFile (getWritePath rp fs) $
                                                BS.pack binary
  (   _,     _, errs) -> do putStrLn (concat errs ++ usageInfo header options)
                            exitWith (ExitFailure 1)

getWritePath :: String -> [ String ] -> FilePath
getWritePath _  (wp:[]) = wp
getWritePath rp _       = replaceExtension rp ".o"

header :: String
header = "Usage: " ++ assembler_msg

assembler_msg :: String
assembler_msg = "assemble [-a] read_path.asm [write_path.o]"
